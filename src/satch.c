/*------------------------------------------------------------------------*/

// This is the library code of the SAT solver Satch with API in 'satch.h'.

// The full code of the library is contained in this file except for the
// header files 'satch.h', 'colors.h', 'stack.h' and 'features.h', and the
// three functions 'satch_compile', 'satch_identifier', and 'satch_version',
// which provide build information and are implemented in 'config.c', which
// in turn is automatically generated by 'mkconfig.sh'.  If you do not need
// those, nor the internal proof checking code in 'catch.[ch]', then you can
// either compile or just link against this file 'satch.c'.

// In order to disable proof checking and debugging (and avoid a link-time
// dependency on 'catch.o') compile with 'NDEBUG' defined.  Not defining
// 'NDEBUG' enables of course also assertion checking in general, also
// witness checking and includes logging code.  The latter still needs to be
// enabled at run-time through 'satch_enable_logging_messages' though.

// So again, if you do not want to use our build set-up, i.e., neither
// './configure' nor 'mkconfig.sh' but just want to link against this
// file instead of linking against the library and do not need proof
// checking in 'catch.c' (because you are not working on the 'satch' library
// itself) then just define 'NDEBUG' by for instance using '-DNDEBUG' as
// compiler option to compile this file and then link to it.

// We do not support assertion checking without internal proof checking (and
// witness checking).  These additional checks increase memory usage by a
// factor of two to four and solving times by up to a factor of five (due to
// simpler and thus slower checker data structures) but are worth to keep
// enabled in testing the library anyhow.  We are not aware of a scenario
// where production use of the solver would require to change this.

/*------------------------------------------------------------------------*/

#include "satch.h"		// API of the solver.

/*------------------------------------------------------------------------*/

#include <assert.h>
#include <math.h>
#include <inttypes.h>
#include <limits.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*------------------------------------------------------------------------*/

// System specific include files for 'getrusage', 'stat', and 'access'.

#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

/*------------------------------------------------------------------------*/

// Rather complex and painful to implement checking of the compatibility of
// disabled features as well as disabling certain features based on other
// disabled features (e.g., if bumping is disabled with 'NBUMP' then VSIDS
// scores are disabled with 'NVSIDS' too).  Including this file also
// provides a consistent feature setting (of 'N...' macros).

// If you want to see which of these macros are actually defined use
// './configure -d' which in turn defines '-DIAGNOSE' and forces printing
// those definitions and in particularly check out 'features/README.md'.

#include "features.h"

/*------------------------------------------------------------------------*/

// Hard coded options for simplicity.

#define slow_alpha              1e-5	// Exponential moving average rate.

#ifndef NSWITCH
#define initial_focused_mode_conflicts 1e3
#define initial_focused_mode_ticks     1e8
#endif

#ifndef NVIVIFICATION
#define vivification_interval 1000 // Base elimination interval.
#endif

#ifndef NELIMINATION

#ifndef NINPROCESSING
#define elimination_interval	500	// Base elimination interval.
#endif

#ifndef NELIMINATIONLIMITS
#ifndef NINPROCESSING
#define elimination_ticks_fraction 0.2	// Ticks fraction in elimination.
#endif
#define elimination_occurrence_limit 1e3
#define elimination_clause_size_limit 100
#define elimination_rounds 2
#endif
#endif

#ifndef NSUBSUMPTION

#ifndef NINPROCESSING
#define subsumption_ticks_fraction 0.1	// Ticks fraction in subsumption.
#endif

#ifndef NSUBSUMPTIONLIMITS
#define subsumption_occurrence_limit 1e3
#define subsumption_clause_size_limit 1e3
#define subsumption_rounds 2
#ifndef NSTRENGTHENING
#define strengthening_occurrence_limit 1e3
#endif
#endif

#endif

#ifndef NSTABLE
#define stable_restart_interval 1024	// Basic stable restart interval.
#endif

#ifndef NMINIMIZE
#define minimize_depth          1e4	// Recursive minimization depth.
#endif

#ifndef NREDUCE
#define reduce_fraction         0.75	// Fraction of reduced clauses.
#ifndef NTIER1
#define tier1_glue_limit        2	// Kept clause glue limit (tier 1).
#ifndef NTIER2
#define tier2_glue_limit        6	// Delayed reduction glue (tier 2).
#endif
#endif
#define reduce_interval         300	// Reduce conflicts interval.
#endif

#ifndef NREPHASE
#define rephase_interval	1e3	// Rephase conflict interval.
#endif

#ifndef NRESTART
#define fast_alpha              3e-2	// Exponential moving average rate.
#define restart_interval        1	// Basic (focused) restart interval.
#define restart_margin          1.1	// Margin for fast_glue > slow_glue.
#endif

#ifndef NBUMPREASONS
#define bump_reason_decision_rate_limit		10
#endif


#ifndef NVSIDS

// Increase factors (inverse of decay) for exponential VSIDS.

#ifndef NFOCUSED
#define focused_score_increment_factor	1.15
#endif

#ifndef NSTABLE
#define stable_score_increment_factor	1.05
#endif

#endif

#ifndef NHEAP
#define MAX_SCORE		1e150	// Maximum score before rescore.
#endif


#ifdef NCDCL
#define DUMMY_REASON    (struct clause *)1 // Dummy constant (not 0).
#endif

/*------------------------------------------------------------------------*/

// Local include files beside 'satch.h' and 'features.h'.

// As explained at the top of this file, there is a dependency on 'catch.h'
// at compile-time and thus 'catch.o' at link-time but only if 'NDEBUG' is
// undefined and thus assertion, proof and witness checking are enabled.
// Thus for production use you really want to define 'NDEBUG'.

#ifndef NDEBUG
#include "catch.h"		// Online proof checker for testing.
#endif

#ifndef NRADIXSORT
#include "rsort.h"		// Generic radix sort implementation.
#endif

#include "qsort.h"		// Generic radix sort implementation.
#include "stack.h"		// Generic stack implementation.
#include "colors.h"		// Shared code for terminal colors.

/*------------------------------------------------------------------------*/

/*------------------------------------------------------------------------*/

// This is the main CDCL solving loop.

static int
solve (struct satch *solver, int delta_limit)
{
  START (solve);
  report (solver, 1, '*');

  int res = solver->inconsistent ? 20 : 0;
  struct clause *conflict;

  uint64_t conflict_limit =
    delta_limit < 0 ? UINT64_MAX : CONFLICTS + delta_limit;

#ifndef NSWITCH
  start_mode (solver);
#endif
  while (!res)
    if ((conflict = boolean_constraint_propagation (solver)))
      {
	if (!analyze_conflict (solver, conflict))
	  res = 20;
      }
    else
      {
	if (solver->iterate)
	  iterate (solver);

	if (!solver->unassigned)
	  res = 10;
	else
	  {
	    if (CONFLICTS >= conflict_limit)
	      break;
	    else
#ifndef NRESTART
	    if (restarting (solver))
	      restart (solver);
	    else
#endif
#ifndef NSWITCH
	    if (switching (solver))
	      switch_mode (solver);
	    else
#endif
#ifndef NREDUCE
	    if (reducing (solver))
	      reduce (solver);
	    else
#endif
#ifndef NREPHASE
	    if (rephasing (solver))
	      rephase (solver);
	    else
#endif
#ifndef NELIMINATION
	    if (eliminating (solver))
	      res = eliminate_variables (solver);
	    else
#endif
#ifndef NVIVIFICATION
	    if (vivifying (solver))
	      res = vivify (solver);
	    else
#endif
	      decide (solver);
	  }
      }
#ifndef NSWITCH
  stop_mode (solver);
#endif

  report (solver, 1, !res ? '?' : res == 10 ? '1' : '0');
  STOP (solve);
  return res;
}

/*------------------------------------------------------------------------*/

#ifndef NDEBUG

// This witness checker goes over the saved original clauses and checks that
// each of them is satisfied.  If not a fatal error message is triggered
// after printing an original clause which was found to be unsatisfied.

static void
check_witness (struct satch *solver)
{
  const int *const begin_original = solver->original.begin;
  const int *const end_original = solver->original.end;
  size_t clauses = 0;
  for (const int *p = begin_original, *c = p; c != end_original; c = p)
    {
      clauses++;
      bool satisfied = false;
      int lit;
      while (assert (p != end_original), (lit = *p++))
	if (satch_val (solver, lit) == lit)
	  satisfied = true;
      if (satisfied)
	continue;
      COLORS (2);
      fflush (stdout);
      fprintf (stderr,
	       "%slibsatch: %sfatal error: %sclause[%zd] unsatisfied:\n",
	       BOLD, RED, NORMAL, clauses);
      for (const int *q = c; (lit = *q); q++)
	fprintf (stderr, "%d ", *q);
      fputs ("0\n", stderr);
      fflush (stderr);
      abort ();
    }

  LOG ("checked witness successfully");
}

#endif

/*------------------------------------------------------------------------*/

// The API functions below have several requirements (contracts) and those
// need to be enforced even in optimized code, particularly in order to help
// library users to detect, test and debug invalid API usage.

static void
invalid_usage (const char *message, const char *function)
{
  COLORS (2);
  fprintf (stderr,
	   "%slibsatch: %sfatal error: %sinvalid API usage in '%s': %s\n",
	   BOLD, RED, NORMAL, function, message);
  fflush (stderr);
  abort ();
}

// Macros to enforce valid API usage.

#define REQUIRE(CONDITION,MESSAGE) \
do { \
  if (!(CONDITION)) \
    invalid_usage (MESSAGE, __func__); \
} while (0)

#define REQUIRE_NON_ZERO_SOLVER() \
  REQUIRE (solver, "zero solver argument")

#define REQUIRE_VALID_LITERAL(ELIT) \
do { \
  REQUIRE ((ELIT) != INT_MIN, "'INT_MIN' literal argument"); \
  REQUIRE (sizeof (void*) > 4 || abs (ELIT) <= (1<<29), \
           "maximum of '2^29' variables exceeded on 32-bit system"); \
} while (0)

#define REQUIRE_NON_ZERO_VALID_LITERAL(ELIT) \
do { \
  REQUIRE ((ELIT), "zero literal argument"); \
  REQUIRE ((ELIT) != INT_MIN, "'INT_MIN' literal argument"); \
} while (0)

#define REQUIRE_NON_INCREMENTAL() \
  REQUIRE (!solver->statistics.solved, \
           "incremental usage not implemented yet")

/*------------------------------------------------------------------------*/

static struct satch *
internal_init (void)
{
  struct satch *solver = calloc (1, sizeof (struct satch));
  if (!solver)
    fatal_error ("could not allocate solver");
#ifdef NFOCUSED
  solver->stable = 1;
#endif
#ifndef NDEBUG
  solver->checker = checker_init ();
#endif
#ifndef NBLOCK
  init_binary (solver);
#endif

#ifndef NVSIDS
#ifndef NFOCUSED
  solver->scores[0].factor = focused_score_increment_factor;
#endif
#ifndef NSTABLE
  solver->scores[1].factor = stable_score_increment_factor;
#endif
#endif

  init_averages (solver);
#ifndef NLIMITS
  init_limits (solver);
#endif
  init_profiles (solver);
  return solver;
}

/*------------------------------------------------------------------------*/

static void
internal_release (struct satch *solver)
{
#ifdef NLEARN
  if (solver->level)
    backtrack (solver, 0);	// To delete reason clauses.
#endif

  solver->proof = 0;
  for (all_literals (lit))
    {
      struct watches *watches = solver->watches + lit;
#if !defined(NDEBUG) && !defined(NVIRTUAL)
      const union watch *const end = watches->end;
      for (const union watch * p = watches->begin; p != end; p++)
	if (p->header.binary)
	  delete_header (solver, lit, p->header);
	else
	  p++;
#endif
      RELEASE_STACK (*watches);
    }

  free (solver->watches);

  free (solver->levels);
  free (solver->values);
#ifndef NSAVE
  free (solver->saved);
#endif
#ifndef NTARGET
  free (solver->targets);
#endif
#ifndef NBEST
  free (solver->bests);
#endif
  free (solver->marks);
#ifndef NVIVIFICATION
  free (solver->vivify_marks);
#endif
  free (solver->flags);
  free (solver->frames);
#ifndef NCONTROL
  free (solver->position);
  RELEASE_STACK (solver->control);
#endif
  free (solver->reasons);
  free (solver->trail.begin);

#ifndef NQUEUE
#ifndef NQUEUE0
  release_queue (&solver->queue[0]);
#else
  assert (!solver->queue[0].links);
#endif
#ifndef NQUEUE1
  release_queue (&solver->queue[1]);
#else
  assert (!solver->queue[1].links);
#endif
#endif

#ifndef NHEAP
#ifndef NHEAP0
  release_heap (&solver->scores[0]);
#else
  assert (!solver->scores[0].begin);
#endif
#ifndef NHEAP1
  release_heap (&solver->scores[1]);
#else
  assert (!solver->scores[1].begin);
#endif
#endif

#ifndef NLAZYACTIVATION
#ifndef NFOCUSED
  RELEASE_STACK (solver->put[0]);
#else
  assert (EMPTY_STACK (solver->put[0]));
#endif
#ifndef NSTABLE
  RELEASE_STACK (solver->put[1]);
#else
  assert (EMPTY_STACK (solver->put[1]));
#endif
#endif

#ifndef NELIMINATION
  RELEASE_STACK (solver->extend);
  RELEASE_STACK (solver->resolvents);
#endif

#ifndef NMINIMIZE
  RELEASE_STACK (solver->poisoned);
  RELEASE_STACK (solver->removable);
#endif
#ifndef NSHRINK
  RELEASE_STACK (solver->shrunken);
#endif
  RELEASE_STACK (solver->analyzed);
  RELEASE_STACK (solver->clause);
  RELEASE_STACK (solver->blocks);
#ifndef NBINARIES
  RELEASE_STACK (solver->binaries);
#endif

  for (all_pointers_on_stack (struct clause, c, solver->irredundant))
      (void) delete_clause (solver, c);
  RELEASE_STACK (solver->irredundant);
#ifndef NLEARN
  for (all_pointers_on_stack (struct clause, c, solver->redundant))
      (void) delete_clause (solver, c);
  RELEASE_STACK (solver->redundant);
#endif
  assert (!solver->statistics.irredundant);
  assert (!solver->statistics.redundant);
#ifndef NBLOCK
  release_binary (solver);
#endif

  RELEASE_STACK (solver->added);
#ifndef NDEBUG
  RELEASE_STACK (solver->original);

#ifndef NLEARN
  checker_enable_leak_checking (solver->checker);
#endif
  checker_release (solver->checker);
#endif
#ifndef NVIVIFICATION
  RELEASE_STACK (solver->vivification_schedule);
  RELEASE_STACK (solver->sorted);
#endif
  free (solver);
}

/*------------------------------------------------------------------------*/

static void
internal_add (struct satch *solver, int elit)
{
#ifndef NDEBUG
  PUSH (solver->original, elit);
#endif

  // If an empty clause has been added or derived we do not need to add
  // anything and just return for the rest of time this solver is used.

  if (solver->inconsistent)
    return;

  if (elit)
    {
      // Add the literal to the internal temporary 'clause' after importing
      // it, i.e., adjusting the 'size' (number of active variables) if its
      // variable has never been seen before.  Also turn the external signed
      // DIMACS 'int' literal into and internal 'unsigned' literal.

      const unsigned ilit = import_literal (solver, elit);
      PUSH (solver->clause, ilit);
      PUSH (solver->added, elit);
#ifndef NDEBUG
      checker_add_literal (solver->checker, elit);
#endif
    }
  else
    {
#ifndef NDEBUG
      checker_add_original_clause (solver->checker);
#endif
      bool remove_original_clause;

      // First check whether the imported clause is already (root-level)
      // satisfied or trivial (contains both a literal and its negation).
      // During this check falsified and duplicated literals are removed.

      if (!imported_clause_trivial_or_satisfied (solver))
	{
	  // Activate variables in the order they appear in the input CNF.
	  // This gives an implicit order of the variables in the decision
	  // queue as well as in the binary heap keeping variables in the
	  // same clauses close to each other which seems beneficial.

	  activate_literals (solver);

	  // We need special treatment for empty and unary clauses since all
	  // internally allocated clauses have at least two literals.

	  const size_t size = SIZE_STACK (solver->clause);

	  if (!size)
	    {
	      LOG ("empty thus inconsistent imported clause");
	      solver->inconsistent = true;
	    }
	  else if (size == 1)
	    {
	      // It is a common technique to represent unit clauses by just
	      // assigning its literal on the root-level.  This makes sure
	      // that all allocated clauses are at least binary, but for
	      // instance requires that 'analyze' treats root-level literals
	      // in a special way, 'reduce' and thus 'assign' ignore
	      // clauses forcing root-level assigned literals and finally
	      // (and maybe really the most severe consequence), makes proof
	      // tracing semantics rather complex (particularly regarding the
	      // situation of deleting unit clauses in RUP / DRAT proofs).

	      const unsigned unit = ACCESS (solver->clause, 0);
	      const signed char value = solver->values[unit];
	      if (value > 0)
		{
		  LOG ("skipping redundant unit clause %s", LOGLIT (unit));
		}
	      else if (value < 0)
		{
		  LOG ("found inconsistent unit clause %s", LOGLIT (unit));
		  solver->inconsistent = true;
		}
	      else
		{
		  LOG ("found unit clause %s", LOGLIT (unit));
		  assign (solver, unit, 0, true);
		  remove_original_clause = true;
		}
	    }
#ifndef NVIRTUAL
	  else if (size == 2)
	    {
	      add_new_binary_and_watch_it (solver, false);
#ifdef LOGGING
	      const unsigned lit = ACCESS (solver->clause, 0);
	      const unsigned other = ACCESS (solver->clause, 1);
	      LOGBIN (false, lit, other, "imported");
#endif
	    }
#endif
	  else
	    {
	      struct clause *clause = new_irredundant_clause (solver);
	      LOGCLS (clause, "imported");
#ifndef NWATCHES
	      watch_clause (solver, clause);
#else
	      connect_clause (solver, clause);
	      count_clause (solver, clause);
#endif
	    }

	  const size_t added = SIZE_STACK (solver->added);
	  assert (size <= added);

	  if (size < added)
	    {
	      trace_and_check_temporary_addition (solver);
	      remove_original_clause = true;
	    }
	  else
	    remove_original_clause = false;
	}
      else
	remove_original_clause = true;

      CLEAR_STACK (solver->clause);
      if (remove_original_clause)
	{
	  if (solver->proof)
	    {
	      start_deletion_proof_line (solver);
	      for (all_elements_on_stack (int, lit, solver->added))
		  add_external_literal_to_proof_line (solver, lit);
	      end_proof_line (solver);
	    }
#ifndef NDEBUG
	  for (all_elements_on_stack (int, lit, solver->added))
	      checker_add_literal (solver->checker, lit);
	  checker_delete_clause (solver->checker);
#endif
	}
      CLEAR_STACK (solver->added);
    }
}

/*========================================================================*/
//    Below are the non-static functions accessible through the API.      //
/*========================================================================*/

struct satch *
satch_init (void)
{
  return internal_init ();
}

void
satch_release (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  internal_release (solver);
}

/*------------------------------------------------------------------------*/

// Add a literal to an internal temporary clause or if the literal argument
// is zero then add a new irredundant / original clause to the solver which
// consists of all the previously literals added to the temporary clause.

void
satch_add (struct satch *solver, int elit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  REQUIRE_VALID_LITERAL (elit);
  internal_add (solver, elit);
}

/*------------------------------------------------------------------------*/

// Short hand for adding empty, unit, binary, ternary, or quaternay clauses.

void
satch_add_empty (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  internal_add (solver, 0);
}

void
satch_add_unit (struct satch *solver, int unit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  REQUIRE_NON_ZERO_VALID_LITERAL (unit);
  internal_add (solver, unit);
  internal_add (solver, 0);
}

void
satch_add_binary_clause (struct satch *solver, int a, int b)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  REQUIRE_NON_ZERO_VALID_LITERAL (a);
  REQUIRE_NON_ZERO_VALID_LITERAL (b);
  internal_add (solver, a);
  internal_add (solver, b);
  internal_add (solver, 0);
}

void
satch_add_ternary_clause (struct satch *solver, int a, int b, int c)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  REQUIRE_NON_ZERO_VALID_LITERAL (a);
  REQUIRE_NON_ZERO_VALID_LITERAL (b);
  REQUIRE_NON_ZERO_VALID_LITERAL (c);
  internal_add (solver, a);
  internal_add (solver, b);
  internal_add (solver, c);
  internal_add (solver, 0);
}

void
satch_add_quaternary_clause (struct satch *solver, int a, int b, int c, int d)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_INCREMENTAL ();
  REQUIRE_NON_ZERO_VALID_LITERAL (a);
  REQUIRE_NON_ZERO_VALID_LITERAL (b);
  REQUIRE_NON_ZERO_VALID_LITERAL (c);
  REQUIRE_NON_ZERO_VALID_LITERAL (d);
  internal_add (solver, a);
  internal_add (solver, b);
  internal_add (solver, c);
  internal_add (solver, d);
  internal_add (solver, 0);
}

/*------------------------------------------------------------------------*/

// Reserve at least 'max_var' variables that is the size of the solver. If
// the users knows this number then pre-allocating everything to that size
// avoids resizing the solver data.

void
satch_reserve (struct satch *solver, int max_var)
{
  REQUIRE_NON_ZERO_SOLVER ();
  assert (0 <= max_var);
  const size_t requested_capacity = max_var;
  if (requested_capacity > solver->capacity)
    increase_capacity (solver, requested_capacity);
}

int
satch_maximum_variable (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  assert (solver->size <= (unsigned) INT_MAX);
  return solver->size;
}

/*------------------------------------------------------------------------*/

// The IPASIR interface returns '-elit' if 'elit' is assigned 'false' and
// 'elit' if it is assigned to 'true'.  Otherwise it returns zero.  We do
// not want to use 'import_literal' here, since this forces to adapt the
// size (and capacity) of the solver to this literal even though it did not
// occur in a clause yet.  So we only import here implicitly.

int
satch_val (struct satch *solver, int elit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_ZERO_VALID_LITERAL (elit);
  REQUIRE (solver->status == 10,
	   (solver->status == 20 ?
	    "expected status to be '10' and not '20'" :
	    !solver->status ?
	    "expected status to be '10' and not '0'" :
	    "expected status to be '10'"));
  int eidx = abs (elit);
  assert (eidx > 0);
  assert (eidx != INT_MIN);
  const unsigned iidx = eidx - 1;
  if (iidx >= solver->size)
    return eidx;		// By default assigned to 'true'.
  const unsigned ilit = LITERAL (iidx);
  signed char tmp = solver->values[ilit];
  if (!tmp)
    return eidx;		// By default assigned to 'true'.
  int res = (tmp > 0) ? elit : -elit;
  if (elit < 0)
    res = -res;
  assert (res == elit || res == -elit);
  return res;
}

int
satch_solve (struct satch *solver, int conflict_limit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE (EMPTY_STACK (solver->clause),
	   "incomplete clause (zero literal missing)");
  REQUIRE (!solver->status, "no incremental solving yet");
  INC (solved);
  if (solver->options.verbose)
    internal_section (solver, "solving");
  int res = solve (solver, conflict_limit);
  LOG ("internal solving procedure returns '%d'", res);
  solver->status = res;
  if (res == 10)
    {
#ifndef NELIMINATION
      extend_solution (solver);
#endif

#ifndef NDEBUG
      check_witness (solver);
#endif
    }
  return res;
}

/*------------------------------------------------------------------------*/

void
satch_set_verbose_level (struct satch *solver, int new_verbose_level)
{
  REQUIRE_NON_ZERO_SOLVER ();
  if (new_verbose_level < 0)
    new_verbose_level = 0;
#ifndef NDEBUG
  if (new_verbose_level > 1)
    checker_verbose (solver->checker);
#endif
  solver->options.verbose = new_verbose_level;
}

void
satch_enable_logging_messages (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
#ifndef NDEBUG
  checker_logging (solver->checker);
  checker_verbose (solver->checker);
#endif
#ifdef LOGGING
  solver->options.logging = true;
#endif
  solver->options.verbose = INT_MAX;
}

void
satch_ascii_proof (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  solver->options.ascii = true;
}

void
satch_trace_proof (struct satch *solver, FILE * proof)
{
  REQUIRE_NON_ZERO_SOLVER ();
  solver->proof = proof;
}

/*------------------------------------------------------------------------*/

double
satch_process_time (void)
{
  return process_time ();
}

void
satch_start_profiling_parsing (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  START (parse);
}

double
satch_stop_profiling_parsing (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  return STOP (parse);
}

void
satch_section (struct satch *solver, const char *name)
{
  REQUIRE_NON_ZERO_SOLVER ();
  internal_section (solver, name);
}

void
satch_statistics (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  const double stop = print_profiles (solver);
  print_statistics (solver, stop);
  print_resource_usage (solver, stop);
}

int
satch_conflicts (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  const uint64_t conflicts = solver->statistics.conflicts;
  return (conflicts > (uint64_t) INT_MAX) ? INT_MAX : conflicts;
}
